package SPM::PackageListFile;
#+############################################################################
#
# File: PackageListFile.pm
#

=head1 NAME

SPM::PackageListFile - Manipulations of a file containing a list of packages

=head1 SYNOPSIS

    use SPM::PackageListFile;
    ..
    $pkgf = SPM::PackageListFile->new( "./packages" );
    ..
    if ($pkgf->exists()) {
	print "Package file already exists.\n";
    }
    ..
    # Get a list of packages from a file
    #
    if ($pkgs = $pkgf->read()) {
	print scalar(@$pkgs)." packages read from file.\n";
    }
    ..
    # Write a list of packages to a file
    #
    if ($pkgs->write( \@pkgs ) {
	print scalar(@pkgs)." packages written to file.\n";
    }

=head1 DESCRIPTION   

    Instances of this class allow lists of SPM::Packages to be read
    and written to files.

=over

=cut

use strict;
use vars qw(@ISA $VERSION $this_app);

use LC::Exception qw(SUCCESS throw_error);
use LC::File qw(file_contents);
use File::stat ();

use CAF::Object;
use CAF::Reporter;

use SPM::Package ();

$VERSION = 1.00;
@ISA = qw(CAF::Object CAF::Reporter);
*this_app = \$main::this_app;

#============================================================================#
# new
#----------------------------------------------------------------------------#

=item new( PATH )

    $pkgf = SPM::PackageListFile->new( "./packages" );

    Create a new PackageListFile instance. PATH is the file system
    location of the package list to be read or written.

=cut

#-----------------------------------------------------------------------------#
sub _initialize {
    my $self = shift;

    my $path = shift;

    $self->_set_path($path);

    return 1;
}
#============================================================================#
# exists
#----------------------------------------------------------------------------#

=item exists( ):BOOL

    if ($pkgf->exists()) {
	print "Package file already exists.\n";
    }    

    Return 1 if the PATH given to the object constructor locates an
    existing file.

=cut

#-----------------------------------------------------------------------------#
sub exists {
    my $self = shift;

    return -e $self->_get_path();
}
#============================================================================#
# read
#----------------------------------------------------------------------------#

=item read( ):LIST

    $pkgs = $pkgf->read();

    Return a reference to an array of SPM::Package instances created
    from data in the associated file.

=cut

#-----------------------------------------------------------------------------#
sub read {
    my $self = shift;

    # Read from a file and return ref to array of Packages.

    my $lst;
    my @pkgList = ();

    if ($self->exists()) {
	$lst = file_contents($self->_get_path());
	unless ( defined($lst) ) {
	    return;
	} 
	my @lst = split(/\n/,$lst);
	while (@lst) {
	    my $txt = shift(@lst);
	    # Strip off any comments

	    $txt =~ s/(.*)#.*/$1/;

	    # Skip over blank lines or those beginning with #
	    unless ($txt =~ /^( *$| *#)/ ) {
		my $pkg = SPM::Package->new( $txt );
		return unless $pkg;
		push(@pkgList,$pkg);
	     }
	 }
    }

    return \@pkgList;
}
#============================================================================#
# write
#----------------------------------------------------------------------------#

=item write( LISTREF ):BOOL

    $status = $pkgs->write( \@pkgs );
  
    Write each package in the input list into the associated file.

=cut

#-----------------------------------------------------------------------------#
sub write {
    my $self = shift;

    # Return managed package list as text in a scalar

    my $pkgList = shift;

    if ( ! (defined($pkgList) && ref($pkgList) ) ) {

	throw_error("_userManagedList expects an array reference");
	return;
	
    } else {

	# Write the list

	my $str = "#\n";
	$str .= "# SPMA Managed Packages list file\n";
	$str .= "# Updated: ".scalar(localtime)."\n";
	$str .= "# SPMA version ". $this_app->version()."\n";
	$str .= "# Package management is: ".$this_app->option('packager')."\n";
	$str .= "# The packages listed here are managed by the SPMA.\n";
	$str .= "# Line format: <package name> <version> <release> <arch>\n";
	$str .= "#\n# DO NOT EDIT THIS FILE\n#\n";

	foreach my $pkg (@$pkgList) {
	    # We only ever write out WANTED non-local packages or
	    # locally managed "unwanted" packages.
	    if ((! $pkg->get_attrib()->{ISLOCAL} &&
		 ! $pkg->get_attrib()->{ISUNWANTED} ) ||
		( $pkg->get_attrib()->{ISLOCAL} &&
		  $pkg->get_attrib()->{ISUNWANTED} ) ) {
		if ($str) {
		    $str = join("\n",$str,$pkg->print());
		} else {
		    $str = $pkg->print();
		}
	    }
	}
	$self->verbose('writing package list to: '.$self->_get_path());
	return file_contents($self->_get_path(), $str);

    }
}
#============================================================================#
# _get_path, _set_path - private
#----------------------------------------------------------------------------#
sub _get_path {
    my $self = shift;
    return $self->{_PATH};
}
sub _set_path {
    my $self = shift;
    return $self->{_PATH} = shift;
}
#+#############################################################################
1;

=back

=head1 AUTHORS

Ian Neilson, minor modifs by German Cancio

=head1 VERSION

$Id: PackageListFile.pm.cin,v 1.1 2003/08/21 16:07:28 gcancio Exp $

=cut



