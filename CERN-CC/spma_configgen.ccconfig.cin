#!@PERL_EXECUTABLE@ -w


use strict;

#
# small script to write out an SPMA config file
# using CCConfig
#
# $Id: spma_configgen.ccconfig.cin,v 1.3 2004/04/08 15:17:35 gcancio Exp $
#

BEGIN {
  unshift (@INC,'/usr/sue/dist/lib/sue');
}

use Getopt::Long;
use strict;

use CCConfig;

#
# unescape($string): $string
#
# small function for unescaping 'forbidden' chars in resource names
#
#sub unescape ($) {
#  my $str=shift;
#
#  $str =~ s!(_[0-9a-f]{2})!sprintf("%c",hex($1))!eg;
#  return $str;
#}


#
# write_spma_config($filename): bool
#
# write a SPMA configuration file specified in $spma_cfg
#
sub write_spma_config ($) {
  my ($spma_cfg)=@_;


  my %rep=CCConfig::Repositories();
  unless (%rep) {
    warn ('could not get repository information');
    return undef;
  }

  my %pkgs=CCConfig::Packages();

  #
  # build the config file
  #

  my $error=0;

  local(*CFG);
  unless(open(CFG,">$spma_cfg.$$")) {
    warn ("cannot open $spma_cfg.$$");
    return undef;
  }

  print CFG "#\n#\n# generated by $0 at ".scalar(localtime)."\n#\n#\n";
  my ($p,$v, $ver,$rel);
  foreach $p (keys %pkgs) {
#    my $pkgstring=&unescape($p);
    my $pkgstring=$p;
    foreach $v (keys %{$pkgs{$p}}) {
#      my $verstring=&unescape($v);
      my $verstring=$v;
      # SPMA wants separate version and release
      ($ver,$rel)=split('-',$verstring);
      unless (exists($pkgs{$p}{$v}{'repository'})) {
	  print "[ERROR] repository not found for package: $pkgstring-$verstring\n";
	  $error++;
	  next;
      }
      unless (exists($rep{$pkgs{$p}{$v}{'repository'}}{'http'})) {
	  print "[ERROR] no HTTP protocol found for repository ".
		$pkgs{$p}{$v}{'repository'}."\n";
	  $error++;
	  next;
	  # this is arbitrary. In a final component version,
	  # there should be the possibility of specifying
	  # which protocols are acceptable (ordered list)
      }
      #
      # flags
      #
      my (@flags,$f);
      #    foreach $f (keys %{$i->{'flags'}}) {
      #      if ($i->{'flags'}->{$f} eq 'true') {
      #	push(@flags,uc($f));
      #      }
      #    }
      print CFG $rep{$pkgs{$p}{$v}{'repository'}}{'http'} .' '.$pkgstring.
	' '.$ver.' '.$rel.' '.$pkgs{$p}{$v}{'arch'}.' '.
	  join(' ',@flags)."\n";
    }
  }

  unless(close(CFG)) {
    warn("cannot close $spma_cfg.$$");
    return undef;
  }

  unless ($error) {
      unless (rename ("$spma_cfg.$$",$spma_cfg)) {
	  $error++;
	  print "[ERROR] cannot rename temporary $spma_cfg.$$ to $spma_cfg\n";
      }
  } else {
      unlink ("$spma_cfg.$$");
  }
  return $error ? undef : 1;
}



#
# main loop
#


my ($spma_conf);


GetOptions(
	   'spmaconf:s' => \$spma_conf)
    or  die("$0: generate SPMA config file \
use: $0 [--spmaconf spmaconffile]\n");


$spma_conf = '/var/lib/spma-target.cf'
  unless (defined $spma_conf);


&write_spma_config($spma_conf) || die ("[ERROR] error generating SPMA config");

exit(0);
